initSidebarItems({"fn":[["rbd_aio_create_completion",""],["rbd_aio_discard",""],["rbd_aio_flush",""],["rbd_aio_get_return_value",""],["rbd_aio_is_complete",""],["rbd_aio_read",""],["rbd_aio_release",""],["rbd_aio_wait_for_complete",""],["rbd_aio_write",""],["rbd_break_lock","Release a shared or exclusive lock that was taken by the specified client."],["rbd_clone","Clone a parent rbd snapshot into a COW sparse child."],["rbd_clone2","Clone a parent rbd snapshot into a COW sparse child."],["rbd_close",""],["rbd_copy",""],["rbd_copy2",""],["rbd_copy_with_progress",""],["rbd_copy_with_progress2",""],["rbd_create",""],["rbd_create2",""],["rbd_create3","create new rbd image"],["rbd_diff_iterate","get difference between two versions of an image"],["rbd_discard","Trim the range from the image. It will be logically filled with zeroes. # Arguments  * `image` the image to trim a range from  * `ofs` offset to start from  * `len` bytes of image to trim"],["rbd_flatten",""],["rbd_flush","Start a flush if caching is enabled. Get a callback when the currently pending writes are on disk. # Arguments  * `image` the image to flush writes to  * `c` what to call when flushing is complete @returns 0 on success, negative error code on failure"],["rbd_get_features",""],["rbd_get_old_format",""],["rbd_get_overlap",""],["rbd_get_parent_info",""],["rbd_get_size",""],["rbd_get_stripe_count",""],["rbd_get_stripe_unit",""],["rbd_invalidate_cache","Drop any cached data for an image"],["rbd_list","List image names."],["rbd_list_children","List all images that are cloned from the image at the snapshot that is set via rbd_snap_set()."],["rbd_list_lockers","List clients that have locked the image and information about the lock."],["rbd_lock_exclusive","Take an exclusive lock on the image. # Arguments  * `image` the image to lock  * `cookie` user-defined identifier for this instance of the lock @returns 0 on success, negative error code on failure @returns -EBUSY if the lock is already held by another (client, cookie) pair @returns -EEXIST if the lock is already held by the same (client, cookie) pair"],["rbd_lock_shared","Take a shared lock on the image."],["rbd_open",""],["rbd_open_read_only","Open an image in read-only mode."],["rbd_read",""],["rbd_read_iterate2","iterate read over an image Reads each region of the image and calls the callback.  If the buffer pointer passed to the callback is NULL, the given extent is defined to be zeros (a hole).  Normally the granularity for the callback is the image stripe size. # Arguments  * `image` image to read  * `ofs` offset to start from  * `len` bytes of source image to cover  * `cb` callback for each region @returns 0 success, error otherwise"],["rbd_remove","Delete an RBD image. This may take a long time, since it does not return until every object that comprises the image has been deleted. Note that all snapshots must be deleted before the image can be removed."],["rbd_remove_with_progress",""],["rbd_rename","Rename an RBD image."],["rbd_resize","Change the size of the image."],["rbd_resize_with_progress",""],["rbd_snap_create",""],["rbd_snap_is_protected","Determine whether a snapshot is protected."],["rbd_snap_list",""],["rbd_snap_list_end",""],["rbd_snap_protect","Prevent a snapshot from being deleted until it is unprotected."],["rbd_snap_remove",""],["rbd_snap_rollback",""],["rbd_snap_rollback_with_progress",""],["rbd_snap_set",""],["rbd_snap_unprotect","Allow a snaphshot to be deleted"],["rbd_stat","Get information about the image. Currently parent pool and parent name are always -1 and ‘’."],["rbd_unlock","Release a shared or exclusive lock on the image."],["rbd_version","Get the version number of the librbd C library."],["rbd_write",""]],"struct":[["rbd_image_info_t",""],["rbd_snap_info_t",""]],"type":[["librbd_progress_fn_t",""],["rbd_callback_t",""],["rbd_completion_t",""],["rbd_image_t",""],["rbd_snap_t",""]]});